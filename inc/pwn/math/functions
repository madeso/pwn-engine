#ifndef PWN_MATH_FUNCTIONS
#define PWN_MATH_FUNCTIONS

#include <pwn/math/config>

namespace pwn
{
	namespace math
	{
		struct vec2;
		struct vec3;
		struct point2;
		struct direction2;
		struct rect;
		struct Angle;
		struct quat;
		struct AxisAngle;
		//struct Euler;

		/////////////////////////////////////////////////////////////////////////////////////////////
		// math1

		const int Sign(const real r);
		// larger smoothing values result in a smoother but less resposive path
		const real Curve(const real newValue, const real oldValue, const real smoothingValue);
		const real Abs(const real r);
		const real Square(const real r);
		const real Sqrt(const real r);
		const real Min(const real lhs, const real rhs);
		const real Max(const real lhs, const real rhs);
		const real Limmit(const real min, const real value, const real max);
		const real To01(const real L, const real v, const real R);
		const real From01(const real L, const real v, const real R);
		const real Remap(const real ol, const real or, const real v, const real nl, const real nr);
		const real Get360Angular(const real min, const real val,const real max);
		const real Within(const real min, const real v, const real max);
		const bool IsWithin(const real min, const real c, const real max);
		const real Wrap(const real min, const real value, const real max);
		const int Wrapi(const int min, const int value, const int max);
		// return number of wraps (with sign)
		const int IncrementAndWrap(const real min, real* current, const real change, const real max);
		const int IncrementAndWrapi(const int min, int* current, const int change, const int max);
		// constants
		const real Pi();
		const real HalfPi();
		const bool kTrue();
		const bool kFalse();

		//////////////////////////////////////////////////////////////////////////////////////////////////
		// vec2

		real LengthOf(const vec2& vec);
		real LengthOfSquared(const vec2& vec);

		const vec2 GetNormalized(const vec2& vec);
		void Normalize(vec2* vec);

		const vec2 operator+(const vec2& lhs, const vec2& rhs);
		const vec2 operator-(const vec2& lhs, const vec2& rhs);

		const vec2 operator*(const real scalar, const vec2& vec);
		const vec2 operator*(const vec2& vec, const real scalar);

		const vec2 operator/(const vec2& vec, const real scalar);
		const vec2 operator-(const vec2& vec);

		const vec2 Curve(const vec2& target, const vec2& old, float smoothing);
		const vec2 FromTo(const vec2& from, const vec2& to);

		//////////////////////////////////////////////////////////////////////////////////////////////////
		// vec3

		real LengthOf(const vec3& vec);
		real LengthOfSquared(const vec3& vec);

		const vec3 GetNormalized(const vec3& vec);
		void Normalize(vec3* vec);

		const vec3 operator+(const vec3& lhs, const vec3& rhs);
		const vec3 operator-(const vec3& lhs, const vec3& rhs);

		const vec3 operator*(const real scalar, const vec3& vec);
		const vec3 operator*(const vec3& vec, const real scalar);

		const vec3 operator/(const vec3& vec, const real scalar);
		const vec3 operator-(const vec3& vec);

		const vec3 cross(const vec3& lhs, const vec3& rhs);
		const real dot(const vec3& lhs, const vec3& rhs);

		const vec3 crossNorm(const vec3& lhs, const vec3& rhs);

		const vec3 Right();
		const vec3 In();
		const vec3 Up();

		const vec3 Left();
		const vec3 Out();
		const vec3 Down();

		const Angle AngleBetween(const vec3& a, const vec3& b);
		const Angle AngleBetween(const vec3& a, const vec3& b, const vec3& perpa);

		vec3 Curve(const vec3& target, const vec3& old, real smoothing);
		vec3 lerp(const vec3& f, real scale, const vec3& t);

		const vec3 FromTo(const vec3& from, const vec3& to);

		//////////////////////////////////////////////////////////////////////////////////////////////////
		// quat

		const quat quatw(const real aw, const real ax, const real ay, const real az);

		real LengthOf(const quat& q);
		real LengthOfSquared(const quat& q);

		const quat GetNormalized(const quat& q);
		void Normalize(quat* q);

		const quat GetConjugate(const quat& q);
		const void Conjugate(quat* q);
		const quat operator*(const quat& lhs, const quat& rhs);

		const vec3 In(const quat& q);
		const vec3 Right(const quat& q);
		const vec3 Up(const quat& q);

		const vec3 RightUpIn(const quat& q, const vec3& v);

		const vec3 Out(const quat& q);
		const vec3 Left(const quat& q);
		const vec3 Down(const quat& q);

		const vec3 RotateAroundOrigo(const quat& q, const vec3& v);

		const quat Combine(const quat& current, const quat& extra);

		const quat cquat(const AxisAngle& aa);
		const AxisAngle ToAxisAngle(const quat& q);
		//const quat cquat(const Euler& e);

		const quat qIdentity();
		const quat qLookAt(const vec3& from, const vec3& to, const vec3& up);
		const quat qLookInDirection(const vec3& dir, const vec3& up);

		const quat operator+(const quat& lhs, const quat& rhs);
		const quat operator-(const quat& lhs, const quat& rhs);

		const quat operator*(const real scalar, const quat& q);
		const quat operator*(const quat& q, const real scalar);

		const quat operator/(const quat& q, const real scalar);
		const quat operator-(const quat& q);

		real dot(const quat& lhs, const quat& rhs);

		//////////////////////////////////////////////////////////////////////////////////////////////////
		// point2

		//constants
		const point2 Origo2();

		// standard operators
		const point2 operator+(const point2& lhs, const direction2& rhs);
		const point2 operator+(const direction2& lhs, const point2& rhs);
		const point2 operator-(const point2& lhs, const direction2& rhs);
		const point2 operator-(const direction2& lhs, const point2& rhs);

		// uniform scaling
		const point2 operator*(const point2& lhs, const real rhs);
		const point2 operator*(const real lhs, const point2& rhs);

		const float DistanceBetween(const point2& from, const point2& to);

		///////////////////////////////////////////////////////////////////////////////////////////////////
		// direction2

		const direction2 Between(const point2& from, const point2& to);
		const direction2 ToUnit(const direction2& dir);
		const direction2 operator/(const direction2& lhs, const real rhs);
		const direction2 operator*(const direction2& lhs, const real rhs);
		const direction2 operator*(const real lhs, const direction2& rhs);
		const real LengthOf(const direction2& dir);
		const direction2 operator-(const direction2& lhs, const direction2& rhs);
		const direction2 operator+(const direction2& lhs, const direction2& rhs);

		//////////////////////////////////////////////////////////////////////////////////////////////////
		// rect

		const point2 Remap(const rect& from, const point2& p, const rect& to);

		real TopOf(const rect& r);
		real BottomOf(const rect& r);
		real LeftOf(const rect& r);
		real RightOf(const rect& r);

		const rect FromUpperLeftAndSize(const point2& point, const direction2& size);
		const rect FromUpperLeftAndSize(const point2& point, const real width, const real height);
		const rect FromUpperLeftAndSize(const point2& point, const real size);

		const rect FromUpperLeftAndLowerRight(const point2& ul, const point2& lr);

		const rect FromSizeAndCenter(const direction2& size, const point2& center);
		const rect FromSizeAndCenter(const real size, const point2& center);
		const rect FromLrud(const real left, const real right, const real up, const real down);

		const rect MoveCopyTo(const rect& r, const point2& point);

		const rect TurnCopyUpsideDown(const rect& r, const real scale = 1.0f);
		// move
		const rect operator+(const rect& lhs, const direction2& rhs);
		const rect operator+(const direction2& lhs, const rect& rhs);

		// uniform scale
		const rect operator*(const rect& r, const real scale);
		const rect operator*(const real scale, const rect& r);

		const point2 Within(const point2& loc, const rect& region);
		const point2 Within(const point2& loc, const rect& region, const rect& object);
		const bool IsWithin(const point2& loc, const rect& region);
		// IsWithin/DoesOverlap functions for rect-rect functions?

		/////////////////////////////////////////////////////////////////
		// Angle

		const real Sin(const Angle& ang);
		const real Cos(const Angle& ang);
		const real Tan(const Angle& ang);

		const Angle Asin(const real v);
		const Angle Acos(const real v);
		const Angle Atan(const real v);

		const Angle GetWrapped(const Angle& a);

		const Angle operator+(const Angle& lhs, const Angle& rhs);
		const Angle operator-(const Angle& lhs, const Angle& rhs);
		const Angle operator*(const Angle& lhs, const real rhs);
		const Angle operator*(const real rhs, const Angle& lhs);

		const Angle FromPercentOf360(const real percent);
		const Angle Zero();

		/////////////////////////////////////////////////////////////////
		// AxisAngle

		const AxisAngle RightHandAround(const vec3& axis, const Angle& angle);

		///////////////////////////////////////////////////////////////
		// ArcBall
		quat GetRotation(const ArcBall& arc, const vec2 from, const vec2 to);
	}
}

#endif