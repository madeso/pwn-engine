#ifndef PWN_MATH_FUNCTIONS
#define PWN_MATH_FUNCTIONS

#include <pwn/math/config>

namespace pwn
{
	namespace math
	{
		struct vec2;
		struct vec3;
		struct point2;
		struct direction2;
		struct rect;
		struct Angle;
		struct quat;
		struct mat33;
		struct AxisAngle;
		//struct Euler;

		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup math1 1-D math functions
		/// @{

		/** Calculates the sign as a positive or a negative int.
		@returns 1 if r is greater than 0, -1 if not.
		@see Abs()
		*/
		const int Sign(const real r);

		/** Performs a single interpolating step to transform a old value to a new value.
		Larger smoothing values result in a smoother but less resposive path

		Example:
		@code mousex = Curve( ( MousePos.X - OldMousePos.X ) * Sensitivity(), mousex, 6 ); @endcode

		@param target is the target value
		@param current is the current value
		@param smoothing is the smoothing value > 0, the lower, the less smooth
		
		@returns The smoothed result.
		*/
		const real Curve(const real target, const real current, const real smoothing);

		/** Calculates the square of the argument.
		@see Sqrt()
		*/
		const real Square(const real r);

		/** Calculates the square-root of the argument.
		@see Square()
		*/
		const real Sqrt(const real r);

		/** Calculates the absolute value of the argument.
		@see Sign()
		*/
		const real Abs(const real r);

		/** Calculates the minimum of two values
		@see Max()
		@see KeepWithin()
		*/
		const real Min(const real lhs, const real rhs);

		/** Calculates the maximum of two values.
		@see Min()
		@see KeepWithin()
		*/
		const real Max(const real lhs, const real rhs);

		/** Transforms a value from one range to the 0-1 range.
		This function does not limmit the value, so if it's below the lower bound it will be below 0.
		@param L the lower bound of the range
		@param v the value
		@param U the upper bound of the range
		@returns The tranformed value.
		@see From01()
		@see Remap()
		@see KeepWithin()
		*/
		const real To01(const real L, const real v, const real U);

		/** Transforms a value from the 0-1 range to another range.
		This function does not limmit he value, so if it's below 0 the result will be below the lower bound.
		@param L the lower bound of the range
		@param v the value
		@param U the upper bound of the range
		@returns The tranformed value
		@see To01()
		@see KeepWithin()
		@see Remap()
		*/
		const real From01(const real L, const real v, const real U);

		/** Remaps/tranforms from one range to another.
		This function does not limmit it's input, so if the value is outside the original range, it will be outside the new range.
		@param ol old lower range
		@param ou old upper range
		@param v the value
		@param nl new lower range
		@param nu new upper range
		@returns The transformed value
		@see From01()
		@see To01()
		@see KeepWithin()
		*/
		const real Remap(const real ol, const real ou, const real v, const real nl, const real nu);

		/** Calculate smooth value suitable for infinite looping.
		@param min is the minimum output value
		@param value is a real that indicates what to return
		             0 means minimum, 0.5 means maximum and 1 is mimimum again, the values inbetween follow a sinus/cosinus curve doing a full 360.
		@param max is the maximum output value
		@returns a value that lies between min and max
		*/
		const real Get360Angular(const real min, const real value, const real max);

		/** Keeps a value within a minimum and a maximum.
		Limmits it to the range if it get's outside.
		@param min is the minimum value
		@param v is the value to limmit
		@param max is the maximum value
		@returns the limmited value
		@see Min()
		@see Max()
		@see Wrap()
		@see IsWithin()
		*/
		const real KeepWithin(const real min, const real v, const real max);

		/** Checks wheter a value is within a range.
		@see KeepWithin()
		*/
		const bool IsWithin(const real min, const real c, const real max);

		/* Keeps a value within a range.
		Wraps it to the others side if it gets outside.
		@param min is the lower range
		@param v is the value to be wrapped
		@param max is the upper range
		@returns the wrapped value
		@see KeepWithin()
		@see Wrapi()
		@see IncrementAndWrap()
		*/
		const real Wrap(const real min, const real v, const real max);

		/* Keeps a value within a range.
		Wraps it to the others side if it gets outside.
		@param min is the lower range
		@param v is the value to be wrapped
		@param max is the upper range
		@returns the wrapped value
		@see KeepWithin()
		@see Wrap()
		@see IncrementAndWrapi()
		*/
		const int Wrapi(const int min, const int v, const int max);

		/** Increment and wrap a value
		@returns return number of wraps (with sign)
		@see Wrap()
		*/
		const int IncrementAndWrap(const real min, real* current, const real change, const real max);

		/** Increment and wrap a value
		@returns return number of wraps (with sign)
		@see Wrapi()
		*/
		const int IncrementAndWrapi(const int min, int* current, const int change, const int max);

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup constants Constants
		/// @{

		/** The matematical constant pi.
		@see HalfPi()
		*/
		const real Pi();

		/** The matematical constant pi divided by 2.
		@see Pi()
		*/
		const real HalfPi();

		/** The boolean value true.
		@see kFalse()
		*/
		const bool kTrue();

		/** The boolean value false.
		@see kTrue()
		*/
		const bool kFalse();

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup vec2 vec2 functions
		/// @{

		/** Calculates the length of a vector.
		@see LengthOfSquared()
		*/
		real LengthOf(const vec2& vec);

		/** Calculates the square length of a vector.
		@see LengthOf()
		*/
		real LengthOfSquared(const vec2& vec);

		/** Calculates the normalized version of a vector.
		@see Normalize()
		*/
		const vec2 GetNormalized(const vec2& vec);

		/* Normalizes a vector.
		@see GetNormalized()
		*/
		void Normalize(vec2* vec);

		/* Generates a direction given two positions.
		@returns a vector pointing from to to.
		*/
		const vec2 FromTo(const vec2& from, const vec2& to);
		const vec2 Curve(const vec2& target, const vec2& old, float smoothing);
		const vec2 ChangeY(const vec2& v, const real newy);

		const vec2 operator+(const vec2& lhs, const vec2& rhs);
		const vec2 operator-(const vec2& lhs, const vec2& rhs);
		const vec2 operator*(const real scalar, const vec2& vec);
		const vec2 operator*(const vec2& vec, const real scalar);
		const vec2 operator/(const vec2& vec, const real scalar);
		const vec2 operator-(const vec2& vec);

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup vec3 vec3 functions
		/// @{

		const vec3 cvec3(const quat& q);
		real LengthOf(const vec3& vec);
		real LengthOfSquared(const vec3& vec);
		const vec3 GetNormalized(const vec3& vec);
		void Normalize(vec3* vec);
		const vec3 cross(const vec3& lhs, const vec3& rhs);
		const real dot(const vec3& lhs, const vec3& rhs);
		const vec3 crossNorm(const vec3& lhs, const vec3& rhs);
		vec3 Curve(const vec3& target, const vec3& old, real smoothing);
		const vec3 FromTo(const vec3& from, const vec3& to);
		vec3 lerp(const vec3& f, real scale, const vec3& t);

		const vec3 operator+(const vec3& lhs, const vec3& rhs);
		const vec3 operator-(const vec3& lhs, const vec3& rhs);
		const vec3 operator*(const real scalar, const vec3& vec);
		const vec3 operator*(const vec3& vec, const real scalar);
		const vec3 operator/(const vec3& vec, const real scalar);
		const vec3 operator-(const vec3& vec);

		const Angle AngleBetween(const vec3& a, const vec3& b);
		const Angle AngleBetween(const vec3& a, const vec3& b, const vec3& perpa);

		const vec3 Right();
		const vec3 In();
		const vec3 Up();

		const vec3 Left();
		const vec3 Out();
		const vec3 Down();

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup quat quat functions
		/// @{

		// "constructor" that takes w element first instead of last
		const quat quatw(const real aw, const real ax, const real ay, const real az);

		const quat cquat(const AxisAngle& aa);

		real LengthOf(const quat& q);
		real LengthOfSquared(const quat& q);
		quat lerp(const quat& a, const float v, const quat& b);
		const quat Slerp(const quat& a, const real v, const quat& b);
		const quat SlerpShortway(const quat& a, const real v, const quat& b);

		const quat GetNormalized(const quat& q);
		void Normalize(quat* q);

		const void Conjugate(quat* q);
		const quat GetConjugate(const quat& q);
		const vec3 In(const quat& q);
		const vec3 Right(const quat& q);
		const vec3 Up(const quat& q);
		const vec3 Out(const quat& q);
		const vec3 Left(const quat& q);
		const vec3 Down(const quat& q);

		const vec3 RightUpIn(const quat& q, const vec3& v);
		const vec3 RotateAroundOrigo(const quat& q, const vec3& v);
		const quat Combine(const quat& current, const quat& extra);
		const quat FpsQuat(const float dx, const float dy);
		//const quat cquat(const Euler& e);
		const quat qIdentity();
		const quat qLookAt(const vec3& from, const vec3& to, const vec3& up);
		const quat qLookInDirection(const vec3& adir, const vec3& up);
		real dot(const quat& lhs, const quat& rhs);
		
		const quat operator*(const quat& lhs, const quat& rhs);
		const quat operator+(const quat& lhs, const quat& rhs);
		const quat operator-(const quat& lhs, const quat& rhs);
		const quat operator*(const real scalar, const quat& q);
		const quat operator*(const quat& q, const real scalar);
		const quat operator/(const quat& q, const real scalar);
		const quat operator-(const quat& q);

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup mat33 mat33 functions
		/// @{

		const vec3 In(const mat33& m);
		const vec3 Right(const mat33& m);
		const vec3 Up(const mat33& m);

		const vec3 Out(const mat33& m);
		const vec3 Left(const mat33& m);
		const vec3 Down(const mat33& m);

		const mat33 Scale(const vec3& scale);

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup point2 point2 functions
		/// @{

		//constants
		const point2 Origo2();

		const float DistanceBetween(const point2& from, const point2& to);
		const point2 ChangeY(const point2& v, const real newy);

		// standard operators
		const point2 operator+(const point2& lhs, const direction2& rhs);
		const point2 operator+(const direction2& lhs, const point2& rhs);
		const point2 operator-(const point2& lhs, const direction2& rhs);
		const point2 operator-(const direction2& lhs, const point2& rhs);

		// uniform scaling
		const point2 operator*(const point2& lhs, const real rhs);
		const point2 operator*(const real lhs, const point2& rhs);

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup direction2 direction2 functions
		/// @{

		const real LengthOf(const direction2& dir);
		const direction2 ToUnit(const direction2& dir);
		const direction2 Between(const point2& from, const point2& to);

		const direction2 operator+(const direction2& lhs, const direction2& rhs);
		const direction2 operator-(const direction2& lhs, const direction2& rhs);
		const direction2 operator*(const direction2& lhs, const real rhs);
		const direction2 operator*(const real lhs, const direction2& rhs);
		const direction2 operator/(const direction2& lhs, const real rhs);

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup rect rect functions
		/// @{

		real TopOf(const rect& r);
		real BottomOf(const rect& r);
		real LeftOf(const rect& r);
		real RightOf(const rect& r);

		const rect FromUpperLeftAndSize(const point2& point, const direction2& size);
		const rect FromUpperLeftAndSize(const point2& point, const real width, const real height);
		const rect FromUpperLeftAndSize(const point2& point, const real size);
		const rect FromUpperLeftAndLowerRight(const point2& ul, const point2& lr);
		const rect FromSizeAndCenter(const direction2& size, const point2& center);
		const rect FromLrud(const real left, const real right, const real up, const real down);
		const rect FromSizeAndCenter(const real size, const point2& center);
		const rect MoveCopyTo(const rect& r, const point2& point);
		const rect TurnCopyUpsideDown(const rect& r, const real scale);
		
		const point2 Remap(const rect& from, const point2& p, const rect& to);
		// WrapWithin?
		const point2 KeepWithin(const point2& loc, const rect& region);
		const point2 KeepWithin(const point2& loc, const rect& region, const rect& extent);
		const bool IsWithin(const point2& loc, const rect& region);

		const rect operator+(const rect& lhs, const direction2& rhs);
		const rect operator+(const direction2& lhs, const rect& rhs);
		const rect operator*(const rect& r, const real scale);
		const rect operator*(const real scale, const rect& r);
		// IsWithin/DoesOverlap functions for rect-rect functions?

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup Angle Angle functions
		/// @{

		const real Sin(const Angle& ang);
		const real Cos(const Angle& ang);
		const real Tan(const Angle& ang);

		const Angle Asin(const real v);
		const Angle Acos(const real v);
		const Angle Atan(const real v);

		const Angle GetWrapped(const Angle& a);

		const Angle operator+(const Angle& lhs, const Angle& rhs);
		const Angle operator-(const Angle& lhs, const Angle& rhs);
		const Angle operator*(const Angle& lhs, const real rhs);
		const Angle operator*(const real rhs, const Angle& lhs);

		const Angle FromPercentOf360(const real percent);
		const Angle Zero();

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup AxisAngle AxisAngle functions
		/// @{

		const AxisAngle RightHandAround(const vec3& axis, const Angle& angle);
		const AxisAngle cAxisAngle(const quat& q);

		/// @}
		//////////////////////////////////////////////////////////////////////////////////////////////////
		/// \defgroup ArcBall ArcBall functions
		/// @{
		quat GetRotation(const ArcBall& arc, const vec2 from, const vec2 to);
	}
}

#endif