#ifndef PWN_MATH_TYPES
#define PWN_MATH_TYPES

#include <pwn/math/config>

namespace pwn
{
	namespace math
	{
		struct vec2;
		struct vec3;
		struct quat;
		struct point2;
		struct direction2;
		struct rect;
		struct AxisAngle;
		struct Angle;
		struct ArcBall;

		/** A 2 dimensional vector.
		*/
		struct vec2
		{
			/** The x value.
			*/
			real x;

			/** The y value.
			*/
			real y;

			/**
			*/
			vec2(const real x, const real y);

			/** a data-pointer.
			@returns a 2-dimensional pointer to the member-variables
			*/
			real* data();
			
			/** a const data-pointer.
			@returns a 2-dimensional const pointer to the member-variables
			*/
			const real* data() const;

			/** index operator.
			valid indices are 0 and 1
			*/
			real& operator[](int index);

			/** const index operator.
			valid indices are 0 and 1
			*/
			const real operator[](int index) const;

			/** vector addition.
			*/
			void operator+=(const vec2& rhs);

			/** vector substraction.
			*/
			void operator-=(const vec2& rhs);

			/** uniform scaling.
			*/
			void operator*=(const real rhs);

			/** uniform scaling.
			*/
			void operator/=(const real rhs);
		};

		/** A 3 dimensional vector.
		*/
		struct vec3
		{
			/** The x value.
			*/
			real x;

			/** The y value.
			*/
			real y;

			/** The z value.
			*/
			real z;

			/**
			*/
			vec3(const real x, const real y, const real z);

			/** a data-pointer.
			@returns a 2-dimensional pointer to the member-variables
			*/
			real* data();
			
			/** a const data-pointer.
			@returns a 2-dimensional const pointer to the member-variables
			*/
			const real* data() const;

			/** index operator.
			valid indices are 0 and 1
			*/
			real& operator[](int index);

			/** const index operator.
			valid indices are 0 and 1
			*/
			const real operator[](int index) const;

			/** vector addition.
			*/
			void operator+=(const vec3& rhs);

			/** vector substraction.
			*/
			void operator-=(const vec3& rhs);

			/** uniform scaling.
			*/
			void operator*=(const real rhs);

			/** uniform scaling.
			*/
			void operator/=(const real rhs);
		};

		/** A quaternion
		*/
		struct quat
		{
			/**
			*/
			real x;

			/** The z value.
			*/
			real y;

			/** The z value.
			*/
			real z;

			/** The z value.
			*/
			real w;

			quat(const real x, const real y, const real z, const real w); // deprecated

			quat(const vec3& v, const real w);
			quat(const real w, const vec3& v);

			void operator*=(const quat& q);
			void operator+=(const quat& rhs);
			void operator-=(const quat& rhs);
			void operator*=(const real rhs);
			void operator/=(const real rhs);
		};

		namespace sizes
		{
			const int mat33_size = 3;
			const int mat33_matrix_size = mat33_size*mat33_size;
		}

		struct mat33
		{
			mat33(const real data[sizes::mat33_matrix_size]);
			real columnMajor[sizes::mat33_matrix_size];
			/*
			*     | 0 3 6 |
			* M = | 1 4 7 |
			*     | 2 5 8 |
			*/

			real at(int row, int column) const;
			real& at(int row, int column);
		};

		namespace sizes
		{
			const int mat44_size = 4;
			const int mat44_matrix_size = mat44_size*mat44_size;
		}

		struct mat44
		{
			mat44(const real data[sizes::mat44_matrix_size]);

			real columnMajor[sizes::mat44_matrix_size];
			/*
			 *     | 0 4 8  12 |
			 * M = | 1 5 9  13 |
			 *     | 2 5 10 14 |
			 *     | 3 7 11 15 |
			 */

			real at(int row, int column) const;
			real& at(int row, int column);
		};

		struct point2
		{
			point2(float x, float y);
			explicit point2(const vec2& data);

			const real x() const;
			const real y() const;

			void operator+=(const direction2& dir);

			vec2 vec;
		};

		struct direction2
		{
			direction2(float x, float y);
			explicit direction2(const vec2& data);

			void operator+=(const direction2& rhs);

			vec2 vec;
		};

		/**
		positive -> right & up
		*/
		struct rect
		{
			rect(const point2& ul, const point2& lr);
			point2 upperLeft;
			point2 lowerRight;
		};

		struct Angle
		{
		public:
			const real inDegrees() const;
			const real inRadians() const;

			static const Angle FromDegrees(real deg);
			static const Angle FromRadians(real rad);

			void wrap();

			void operator+=(const Angle& rhs);
			void operator-=(const Angle& rhs);
			void operator*=(const real r);
		private:
			explicit Angle(real rad);
			real mRad;
		};

		// axis is unit-vector
		// rotation works according to right-hand rule
		struct AxisAngle
		{
			// according to righthand rule, prefer RightHandAround function for documentation purposes
			AxisAngle(const vec3& axis, const Angle& angle);

			vec3 axis;
			Angle angle;
		};

		struct ArcBall
		{
			ArcBall(const vec2& center, const real radius);

			vec2 center;
			real radius;
		};
	}
}

#endif